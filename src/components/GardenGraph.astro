---
import type { CollectionEntry } from 'astro:content';
import { buildLinkGraph } from '../lib/backlinks';

interface Props {
  posts: CollectionEntry<'writing'>[];
}

const { posts } = Astro.props;

// Build the complete link graph
const graph = buildLinkGraph(posts);

// Create nodes for all posts
const nodes = posts
  .filter(p => !p.data.draft)
  .map((post, i) => ({
    id: post.slug,
    title: post.data.title,
    x: 170 + 120 * Math.cos((i * 2 * Math.PI) / Math.max(posts.length, 1)),
    y: 90 + 60 * Math.sin((i * 2 * Math.PI) / Math.max(posts.length, 1)),
  }));

// Create edges from wiki-links
const edges: { source: string; target: string }[] = [];
for (const [slug, node] of graph) {
  for (const targetSlug of node.outgoing) {
    if (graph.has(targetSlug)) {
      edges.push({ source: slug, target: targetSlug });
    }
  }
}

const nodesData = JSON.stringify(nodes);
const edgesData = JSON.stringify(edges);
---

<div class="garden-graph" data-nodes={nodesData} data-edges={edgesData}>
  <canvas
    width="340"
    height="380"
    class="w-full h-auto cursor-grab rounded-sm border border-card bg-paper active:cursor-grabbing"
    aria-label="Garden graph showing all posts and their connections. Scroll to zoom, drag to pan."
  ></canvas>
  <div class="graph-controls absolute bottom-2 right-2 flex gap-1">
    <button class="zoom-btn zoom-out px-2 py-1 text-xs font-sans bg-card border border-ink/10 rounded-sm hover:bg-ink/5 transition-colors" aria-label="Zoom out">−</button>
    <button class="zoom-btn zoom-in px-2 py-1 text-xs font-sans bg-card border border-ink/10 rounded-sm hover:bg-ink/5 transition-colors" aria-label="Zoom in">+</button>
    <button class="zoom-btn zoom-reset px-2 py-1 text-xs font-sans bg-card border border-ink/10 rounded-sm hover:bg-ink/5 transition-colors" aria-label="Reset view">⟲</button>
  </div>
</div>

<style>
  .garden-graph {
    position: relative;
  }
  .graph-controls {
    opacity: 0;
    transition: opacity 0ms;
  }
  .garden-graph:hover .graph-controls {
    opacity: 1;
  }
</style>

<script>
  interface GraphNode {
    id: string;
    title: string;
    x: number;
    y: number;
    vx: number;
    vy: number;
  }

  interface GraphEdge {
    source: string;
    target: string;
  }

  interface ViewTransform {
    scale: number;
    translateX: number;
    translateY: number;
  }

  function initGardenGraph(container: HTMLElement) {
    const canvas = container.querySelector('canvas');
    const zoomInBtn = container.querySelector('.zoom-in');
    const zoomOutBtn = container.querySelector('.zoom-out');
    const zoomResetBtn = container.querySelector('.zoom-reset');
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const nodesAttr = container.getAttribute('data-nodes');
    const edgesAttr = container.getAttribute('data-edges');
    if (!nodesAttr || !edgesAttr) return;

    const nodes: GraphNode[] = JSON.parse(nodesAttr).map((n: GraphNode) => ({
      ...n,
      vx: 0,
      vy: 0,
    }));
    const edges: GraphEdge[] = JSON.parse(edgesAttr);

    // Color configuration
    const colors = {
      node: getComputedStyle(document.documentElement).getPropertyValue('--color-ink').trim() || '#2D2D2D',
      nodeHover: getComputedStyle(document.documentElement).getPropertyValue('--color-accent').trim() || '#0066CC',
      edge: getComputedStyle(document.documentElement).getPropertyValue('--color-secondary').trim() || '#6B6B6B',
      label: getComputedStyle(document.documentElement).getPropertyValue('--color-ink').trim() || '#2D2D2D',
    };

    // Handle dark mode
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    if (isDark) {
      colors.node = '#E5E5E5';
      colors.edge = '#888888';
      colors.label = '#E5E5E5';
    }

    let animationId: number;
    let hoveredNode: GraphNode | null = null;
    let isDragging = false;
    let isPanning = false;
    let dragNode: GraphNode | null = null;
    let lastMousePos = { x: 0, y: 0 };
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    // View transform for zoom/pan
    const transform: ViewTransform = {
      scale: 1,
      translateX: 0,
      translateY: 0,
    };

    // Force simulation parameters
    const centerX = 170;
    const centerY = 190;
    const nodeRadius = 5;
    const repulsionStrength = 1000;
    const springLength = 80;
    const springStrength = 0.005;
    const centerGravity = 0.001;
    const damping = 0.92;

    // Zoom limits
    const MIN_ZOOM = 0.5;
    const MAX_ZOOM = 3;
    const LARGE_LABEL_THRESHOLD = 1.5;

    function updateForces() {
      if (prefersReducedMotion && !isDragging) return;

      // Repulsion between nodes
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const nodeA = nodes[i];
          const nodeB = nodes[j];
          const dx = nodeA.x - nodeB.x;
          const dy = nodeA.y - nodeB.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist > 0 && dist < 100) {
            const force = repulsionStrength / (dist * dist);
            const fx = (dx / dist) * force;
            const fy = (dy / dist) * force;
            nodeA.vx += fx;
            nodeA.vy += fy;
            nodeB.vx -= fx;
            nodeB.vy -= fy;
          }
        }
      }

      // Spring force along edges
      for (const edge of edges) {
        const source = nodes.find(n => n.id === edge.source);
        const target = nodes.find(n => n.id === edge.target);
        if (!source || !target) continue;

        const dx = target.x - source.x;
        const dy = target.y - source.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0) {
          const force = (dist - springLength) * springStrength;
          const fx = (dx / dist) * force;
          const fy = (dy / dist) * force;
          source.vx += fx;
          source.vy += fy;
          target.vx -= fx;
          target.vy -= fy;
        }
      }

      // Center gravity
      for (const node of nodes) {
        const dx = centerX - node.x;
        const dy = centerY - node.y;
        node.vx += dx * centerGravity;
        node.vy += dy * centerGravity;

        // Damping
        if (!isDragging || node !== dragNode) {
          node.vx *= damping;
          node.vy *= damping;
        }

        // Update position
        if (!isDragging || node !== dragNode) {
          node.x += node.vx;
          node.y += node.vy;
        }

        // Keep within bounds (larger canvas for panning)
        node.x = Math.max(nodeRadius, Math.min(340 - nodeRadius, node.x));
        node.y = Math.max(nodeRadius, Math.min(380 - nodeRadius, node.y));
      }
    }

    function worldToScreen(x: number, y: number): { x: number; y: number } {
      return {
        x: x * transform.scale + transform.translateX,
        y: y * transform.scale + transform.translateY,
      };
    }

    function screenToWorld(x: number, y: number): { x: number; y: number } {
      return {
        x: (x - transform.translateX) / transform.scale,
        y: (y - transform.translateY) / transform.scale,
      };
    }

    function draw() {
      ctx.clearRect(0, 0, 340, 380);

      ctx.save();

      // Apply transform
      ctx.translate(transform.translateX, transform.translateY);
      ctx.scale(transform.scale, transform.scale);

      // Draw edges
      ctx.strokeStyle = colors.edge;
      ctx.lineWidth = 1 / transform.scale;
      ctx.globalAlpha = 0.3;

      for (const edge of edges) {
        const source = nodes.find(n => n.id === edge.source);
        const target = nodes.find(n => n.id === edge.target);
        if (!source || !target) continue;

        ctx.beginPath();
        ctx.moveTo(source.x, source.y);
        ctx.lineTo(target.x, target.y);
        ctx.stroke();
      }

      ctx.globalAlpha = 1;

      // Draw nodes
      for (const node of nodes) {
        ctx.beginPath();
        ctx.arc(node.x, node.y, nodeRadius, 0, Math.PI * 2);
        ctx.fillStyle = node === hoveredNode ? colors.nodeHover : colors.node;
        ctx.fill();

        // Highlight ring on hover
        if (node === hoveredNode) {
          ctx.beginPath();
          ctx.arc(node.x, node.y, nodeRadius + 3, 0, Math.PI * 2);
          ctx.strokeStyle = colors.nodeHover;
          ctx.lineWidth = 2 / transform.scale;
          ctx.globalAlpha = 0.5;
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      // Draw labels - show all when zoomed in, or just hovered node
      const LABEL_THRESHOLD = 1.2;
      const showAllLabels = transform.scale >= LABEL_THRESHOLD;

      for (const node of nodes) {
        // Only show label if this node is hovered or we're zoomed in
        if (!showAllLabels && node !== hoveredNode) continue;

        const fontSize = transform.scale >= LARGE_LABEL_THRESHOLD ? 11 : 9;
        ctx.font = `${fontSize}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';

        const labelX = node.x;
        const labelY = node.y - nodeRadius - 8 / transform.scale;

        // Truncate title if too long
        let title = node.title;
        if (title.length > 25) {
          title = title.slice(0, 22) + '...';
        }

        // Measure text for background
        const metrics = ctx.measureText(title);
        const textWidth = metrics.width;
        const textHeight = fontSize / transform.scale;
        const padding = 3 / transform.scale;

        // Draw semi-transparent background pill (only for hovered node)
        if (node === hoveredNode) {
          ctx.fillStyle = isDark ? 'rgba(0, 0, 0, 0.9)' : 'rgba(249, 249, 249, 0.95)';
          ctx.fillRect(
            labelX - textWidth / 2 - padding,
            labelY - textHeight - padding,
            textWidth + padding * 2,
            textHeight + padding * 2
          );
        }

        // Draw text
        ctx.fillStyle = colors.label;
        ctx.fillText(title, labelX, labelY);
      }

      ctx.restore();
    }

    function animate() {
      updateForces();
      draw();
      animationId = requestAnimationFrame(animate);
    }

    // Zoom functions
    function zoomAt(screenX: number, screenY: number, delta: number) {
      const newScale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, transform.scale + delta));

      // Proper zoom-to-mouse: adjust translate so mouse stays over same world point
      const worldX = (screenX - transform.translateX) / transform.scale;
      const worldY = (screenY - transform.translateY) / transform.scale;

      transform.translateX = screenX - worldX * newScale;
      transform.translateY = screenY - worldY * newScale;
      transform.scale = newScale;
    }

    function resetZoom() {
      transform.scale = 1;
      transform.translateX = 0;
      transform.translateY = 0;
    }

    // Mouse interaction
    function getMousePos(evt: MouseEvent): { x: number; y: number } {
      const rect = canvas.getBoundingClientRect();
      const scaleX = 340 / rect.width;
      const scaleY = 380 / rect.height;
      return {
        x: (evt.clientX - rect.left) * scaleX,
        y: (evt.clientY - rect.top) * scaleY,
      };
    }

    function findNodeAtScreenPos(screenPos: { x: number; y: number }): GraphNode | null {
      const worldPos = screenToWorld(screenPos.x, screenPos.y);
      for (const node of nodes) {
        const dx = worldPos.x - node.x;
        const dy = worldPos.y - node.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < (nodeRadius + 5) / transform.scale) {
          return node;
        }
      }
      return null;
    }

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const pos = getMousePos(e);
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      zoomAt(pos.x, pos.y, delta);
    }, { passive: false });

    canvas.addEventListener('mousemove', (e) => {
      const pos = getMousePos(e);

      if (isPanning) {
        const dx = pos.x - lastMousePos.x;
        const dy = pos.y - lastMousePos.y;
        transform.translateX += dx;
        transform.translateY += dy;
        lastMousePos = pos;
        return;
      }

      if (isDragging && dragNode) {
        const worldPos = screenToWorld(pos.x, pos.y);
        dragNode.x = worldPos.x;
        dragNode.y = worldPos.y;
        dragNode.vx = 0;
        dragNode.vy = 0;
        return;
      }

      const node = findNodeAtScreenPos(pos);

      if (node !== hoveredNode) {
        hoveredNode = node;
        canvas.style.cursor = node ? 'pointer' : (isPanning ? 'grabbing' : 'grab');
      }
    });

    canvas.addEventListener('mousedown', (e) => {
      const pos = getMousePos(e);
      const node = findNodeAtScreenPos(pos);

      if (node) {
        isDragging = true;
        dragNode = node;
      } else {
        isPanning = true;
        lastMousePos = pos;
        canvas.style.cursor = 'grabbing';
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;
      isPanning = false;
      dragNode = null;
      canvas.style.cursor = 'grab';
    });

    canvas.addEventListener('mouseleave', () => {
      hoveredNode = null;
      tooltip.classList.add('hidden');
      isDragging = false;
      isPanning = false;
      dragNode = null;
      canvas.style.cursor = 'grab';
    });

    canvas.addEventListener('click', (e) => {
      if (isDragging || isPanning) return;
      const pos = getMousePos(e);
      const node = findNodeAtScreenPos(pos);
      if (node) {
        window.location.href = `/writing/${node.id}`;
      }
    });

    // Control buttons
    zoomInBtn?.addEventListener('click', () => {
      zoomAt(170, 190, 0.3);
    });

    zoomOutBtn?.addEventListener('click', () => {
      zoomAt(170, 190, -0.3);
    });

    zoomResetBtn?.addEventListener('click', () => {
      resetZoom();
    });

    // Start animation
    if (!prefersReducedMotion) {
      animate();
    } else {
      draw();
    }

    // Cleanup on page navigation
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        cancelAnimationFrame(animationId);
      } else if (!prefersReducedMotion) {
        animate();
      }
    });
  }

  // Initialize all garden graphs on the page
  document.querySelectorAll('.garden-graph').forEach(initGardenGraph);
</script>
